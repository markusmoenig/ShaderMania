{"assets":[{"output":null,"id":"B70D5254-D457-4C4D-B704-4C5329822105","data":[],"slots":{},"value":"\/\/ Common code for all Shaders goes here\n","type":5,"name":"Common"},{"output":null,"id":"BA04A3E2-E7D7-422C-8DD5-B96285DDCD3A","data":[],"slots":{},"value":"\/\/ Original shader at https:\/\/www.shadertoy.com\/view\/XsBXWt\n\/\/ Used with permission, thanks Kali!\n\n\/\/ Ported to Metal by @MarkusMoenig\n\n\/\/#define SHOWONLYEDGES\n\/\/#define NYAN \n#define WAVES\n\/\/#define BORDER\n\n#define RAY_STEPS 150\n\n#define BRIGHTNESS 1.2\n#define GAMMA 1.4\n#define SATURATION .65\n\n#define detail .001\n\nconstant const float3 origin=float3(-1.,.7,0.);\n\n\/\/ 2D rotation function\nfloat2x2 rot(float a) {\n\treturn float2x2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat radians(float degree) {\n    return degree * M_PI_F \/ 180.0;\n}\n\nfloat mod(float x, float y) {\n    return x - y * floor(x \/ y);\n}\n \n\/\/ \"Amazing Surface\" fractal\nfloat4 formula(float4 p) {\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\t\tp.y-=.25;\n\t\tfloat2 xy = p.xy * rot(radians(35.));\n\t\tp.xy = xy;\n\t\tp=p*2.\/clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\n\/\/ Distance function\nfloat de(float3 pos, const float t) {\n#ifdef WAVES\n\tpos.y+=sin(pos.z-t*6.)*.15; \/\/waves!\n#endif\n\t\/\/float hid=0.;\n\tfloat3 tpos=pos;\n\ttpos.z = abs(3.0 - mod(tpos.z, 6.0));\n\tfloat4 p=float4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(float2(0.),p.yz-1.5))-1.)\/p.w;\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n\tpos.z=abs(.25-mod(pos.z,.5));\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n\tfloat d=min(fr,ro);\n\treturn d;\n}\n\n\n\/\/ Camera path\nfloat3 path(float ti) {\n\tti*=1.5;\n\tfloat3  p=float3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n\treturn p;\n}\n\n\/\/ Calc normals, and here is edge detection, set to variable \"edge\"\n\nfloat3 normal(float3 p, float t, thread float &edge, const float det) { \n\tfloat3 e = float3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx, t),d2=de(p+e.yxx, t);\n\tfloat d3=de(p-e.xyx, t),d4=de(p+e.xyx, t);\n\tfloat d5=de(p-e.xxy, t),d6=de(p+e.xxy, t);\n\tfloat d=de(p, t);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));\/\/edge finder\n\tedge=min(1.,pow(edge,.55)*15.);\n\treturn normalize(float3(d1-d2,d3-d4,d5-d6));\n}\n\n\/\/ Used Nyan Cat code by mu6k, with some mods\n\/*\nfloat4 rainbow(float2 p)\n{\n\tfloat q = max(p.x,-0.1);\n\tfloat s = sin(p.x*7.0+t*70.0)*0.08;\n\tp.y+=s;\n\tp.y*=1.1;\n\t\n\tfloat4 c;\n\tif (p.x>0.0) c=float4(0,0,0,0); else\n\tif (0.0\/6.0<p.y&&p.y<1.0\/6.0) c= float4(255,43,14,255)\/255.0; else\n\tif (1.0\/6.0<p.y&&p.y<2.0\/6.0) c= float4(255,168,6,255)\/255.0; else\n\tif (2.0\/6.0<p.y&&p.y<3.0\/6.0) c= float4(255,244,0,255)\/255.0; else\n\tif (3.0\/6.0<p.y&&p.y<4.0\/6.0) c= float4(51,234,5,255)\/255.0; else\n\tif (4.0\/6.0<p.y&&p.y<5.0\/6.0) c= float4(8,163,255,255)\/255.0; else\n\tif (5.0\/6.0<p.y&&p.y<6.0\/6.0) c= float4(122,85,255,255)\/255.0; else\n\tif (abs(p.y)-.05<0.0001) c=float4(0.,0.,0.,1.); else\n\tif (abs(p.y-1.)-.05<0.0001) c=float4(0.,0.,0.,1.); else\n\t\tc=float4(0,0,0,0);\n\tc.a*=.8-min(.8,abs(p.x*.08));\n\tc.xyz=mix(c.xyz,float3(length(c.xyz)),.15);\n\treturn c;\n}\n\nfloat4 nyan(float2 p)\n{\n\tfloat2 uv = p*float2(0.4,1.0);\n\tfloat ns=3.0;\n\tfloat nt = iTime*ns; nt-=mod(nt,240.0\/256.0\/6.0); nt = mod(nt,240.0\/256.0);\n\tfloat ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\n\tfloat4 color = texture(iChannel1,float2(uv.x\/3.0+210.0\/256.0-nt+0.05,.5-uv.y-ny));\n\tif (uv.x<-0.3) color.a = 0.0;\n\tif (uv.x>0.2) color.a=0.0;\n\treturn color;\n}\n*\/\n\n\/\/ Raymarching and 2D graphics\n\nfloat3 raymarch(float3 from, float3 dir, thread Data &data) \n{\n\tfloat edge = 0.;\n\tfloat det = 0.;\n\n\tfloat3 p, norm;\n\tfloat d=100.;\n\tfloat totdist=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<25.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p, data.time * 0.5);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d; \n\t\t}\n\t}\n\tfloat3 col=float3(0.);\n\tp-=(det-d)*dir;\n\tnorm=normal(p, data.time * 0.5, edge, det);\n#ifdef SHOWONLYEDGES\n\tcol=1.-float3(edge); \/\/ show wireframe version\n#else\n\tcol=(1.-abs(norm))*max(0.,1.-edge*.8); \/\/ set normal as color with dark edges\n#endif\t\t\n\ttotdist=clamp(totdist,0.,26.);\n\tdir.y-=.02;\n\t\n\tfloat sunsize=7.;\/\/-max(0.,texture(iChannel0,float2(.6,.2)).x)*5.; \/\/ responsive sun size\n\tfloat an=atan2(dir.x,dir.y)+data.time*1.5; \/\/ angle for drawing and rotating sun\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); \/\/ sun\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); \/\/ sun border\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); \/\/ sun rays\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); \/\/ gradient sky\n\t\n\t\/\/ set up background with sky and sun\n\tfloat3 backg=float3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*float3(1.,.8,0.15)*3.);\n\t\t backg+=float3(1.,.9,.1)*s;\n\t\t backg=max(backg,sg*float3(1.,.9,.5));\n\t\n\tcol=mix(float3(1.,.9,.3),col,exp(-.004*totdist*totdist));\/\/ distant fading to sun color\n\tif (totdist>25.) col=backg; \/\/ hit background\n\tcol=pow(col,float3(GAMMA))*BRIGHTNESS;\n\tcol=mix(float3(length(col)),col,SATURATION);\n\t\n#ifdef SHOWONLYEDGES\n\tcol=1.-float3(length(col));\n#else\n\tcol*=float3(1.,.9,.85);\n#ifdef NYAN\n\tdir.yx*=rot(dir.x);\n\tfloat2 ncatpos=(dir.xy+float2(-3.+mod(-t,6.),-.27));\n\tfloat4 ncat=nyan(ncatpos*5.);\n\tfloat4 rain=rainbow(ncatpos*10.+float2(.8,.5));\n\tif (totdist>8.) col=mix(col,max(float3(.2),rain.xyz),rain.a*.9);\n\tif (totdist>8.) col=mix(col,max(float3(.2),ncat.xyz),ncat.a*.9);\n#endif\n#endif\n\treturn col;\n}\n\n\/\/ get camera position\nfloat3 move(thread float3 &dir, thread Data &data) \n{\n    float t = data.time * 0.5;\n\tfloat3 go=path(t);\n\tfloat3 adv=path(t+.7);\n\tfloat hd=de(adv, data.time * 0.5);\n\tfloat3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\t\n\tfloat2 xy = dir.xy * float2x2(cos(an),sin(an),-sin(an),cos(an));\n\tdir.xy = xy;\n\t\n    an=advec.y*1.7;\n    float2 yz = dir.yz * float2x2(cos(an),sin(an),-sin(an),cos(an));\n\tdir.yz = yz;\n\t\n\tan=atan2(advec.x,advec.z);\n\t\n    float2 xz = dir.xz * float2x2(cos(an),sin(an),-sin(an),cos(an));\n\tdir.xz = xz;\n\t\n\treturn go;\n}\n\nvoid mainImage(thread Data &data)\n{\n\tfloat2 uv = (data.uv.xy * data.size.xy) \/ data.size.xy*2.-1.;\n\tfloat2 oriuv=uv;\n\tuv.y*= data.size.y\/ data.size.x;\n\t\/\/float2 mouse=(iMouse.xy\/iResolution.xy-.5)*3.;\n\t\/\/if (iMouse.z<1.) mouse=float2(0.,-0.05);\n\tfloat fov=.9-max(0.,.7-data.time*.3);\n\tfloat3 dir=normalize(float3(uv*fov,1.));\n\t\/\/dir.yz*=rot(mouse.y);\n\t\/\/dir.xz*=rot(mouse.x);\n\tfloat3 from=origin+move(dir, data);\n\tfloat3 color=raymarch(from, dir, data); \n\n\t#ifdef BORDER\n\tcolor=mix(float3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*float2(1.05,1.1))),.3));\n\t#endif\n\n    data.outColor = float4(color,1.);\n}\n ","type":2,"name":"Final"}]}